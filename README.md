# Homework2
Вариант 12

MAIN.CPP

Подключаем библиотеку header.hpp
В функции main осуществляется проверка на количество введённых параметров. Нулевой - адрес файла, первый - режим, второй - имя файла. Если количество параметров не равно трём программа оповещает об ошибке и завершает свою работу.
Далее мы присваиваем соответвтвующим переменным аргументы функции режим (mode) и имя файла (file_name).
Создаём переменную для ключа и вводим его с клавиатуры.
Анализируем режим: если режим "encryption" запускаем функцию с аналогичным названием, используя в качестве аргументов имя файла, в который мы будем вводить зашифрованные данные, и ключ; если режим "decryption" запускаем функцию с аналогичным названием, используя в качестве аргументов имя файла, из которого мы считаем зашифрованные данные, и ключ (должен совпадать с тем, по которому проходила зашифровка); в ином случае выдаётся оповещение об ошибке.

HEADER.HPP

В этом файле хранятся прототипы функций "encryption" и "decryption", а также все необходимые библиотеки.

ENCRYPTION.CPP

Объявляем переменную str, в которую с клавиатуры вводим строку (пароль), которую будем зашифровывать, а также другие переменные, которые будут необходимы для работы кода.
Создаём файловую (на запись) переменную и открываем файл с именем из аргументов функции.
С помощью цикла for с шагом 4 (т.к. в моём варианте блок из 4-х байтов) проходимся по всем символа строки str.
Задаём с помощью функции srand(key) определённое псевдослучайное число при вызове gamma=rand() и записываем его в переменную gamma.
Присваиваем беззнаковым символьным переменным b1-b4 соответствующие символы блока. Начиная с b2 делаем проверку, не кончилась ли строка. Если не кончилась, вписываем символ из str, иначе записываем в переменную ноль.
Формируем блок посредством сдвига на 24, 16, 8 бит влево b1, b2, b3 (которые при переводе их в тип unsigned int выдают код этих символов). Так как заполнение происходит нулями, используя поразрядное "или", получим блок (беззноковое целое), где по очереди записаны b1-b4
Используя поразрядный xor, изменяем блок.
Используем сдвиг (на 4 влево), но чтобы не потерять первые 4 символа, а переместить их в конец, используем поразрядное или с этим же блоком, сдвинутым вправо на 28 (32-4).
Далее посредством сдвига записываем в переменные b1-b4 новые уже зашифрованные символы
Записываем по порядку эти символы в файл.

DECRYPTION.CPP

Открываем файл на считываение, считываем строку, в которую записана зашифрованная строка. Затем проводим все действия, как и в функции ENCRYPTION.CPP, только совершаем в обратном порядке: сперва сдвиг (но уже на 4 вправо), затем поразрядное xor. Формируем из расшифрованных символов символьный массив (строку), которую в конце выводим на экран.
